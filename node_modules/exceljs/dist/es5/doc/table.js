"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var colCache = require('./../utils/col-cache');

var Table =
/*#__PURE__*/
function () {
  function Table(worksheet, table) {
    _classCallCheck(this, Table);

    this.worksheet = worksheet;

    if (table) {
      this.table = table;
      this.validate();
      this.store();
    }
  }

  _createClass(Table, [{
    key: "getFormula",
    value: function getFormula(column) {
      // get the correct formula to apply to the totals row
      switch (column.totalsRowFunction) {
        case 'none':
          return null;

        case 'average':
          return "SUBTOTAL(101,".concat(this.table.name, "[").concat(column.name, "])");

        case 'countNums':
          return "SUBTOTAL(102,".concat(this.table.name, "[").concat(column.name, "])");

        case 'count':
          return "SUBTOTAL(103,".concat(this.table.name, "[").concat(column.name, "])");

        case 'max':
          return "SUBTOTAL(104,".concat(this.table.name, "[").concat(column.name, "])");

        case 'min':
          return "SUBTOTAL(105,".concat(this.table.name, "[").concat(column.name, "])");

        case 'stdDev':
          return "SUBTOTAL(106,".concat(this.table.name, "[").concat(column.name, "])");

        case 'var':
          return "SUBTOTAL(107,".concat(this.table.name, "[").concat(column.name, "])");

        case 'custom':
          return column.totalsRowFormula;

        default:
          throw new Error("Invalid Totals Row Function: ".concat(column.totalsRowFunction));
      }
    }
  }, {
    key: "validate",
    value: function validate() {
      var _this = this;

      var table = this.table; // set defaults and check is valid

      var assign = function assign(o, name, dflt) {
        if (o[name] === undefined) {
          o[name] = dflt;
        }
      };

      assign(table, 'headerRow', true);
      assign(table, 'totalsRow', false);
      assign(table, 'style', {});
      assign(table.style, 'theme', 'TableStyleMedium2');
      assign(table.style, 'showFirstColumn', false);
      assign(table.style, 'showLastColumn', false);
      assign(table.style, 'showRowStripes', false);
      assign(table.style, 'showColumnStripes', false);

      var assert = function assert(test, message) {
        if (!test) {
          throw new Error(message);
        }
      };

      assert(table.ref, 'Table must have ref');
      assert(table.columns, 'Table must have column definitions');
      assert(table.rows, 'Table must have row definitions');
      table.tl = colCache.decodeAddress(table.ref);
      var _table$tl = table.tl,
          row = _table$tl.row,
          col = _table$tl.col;
      assert(row > 0, 'Table must be on valid row');
      assert(col > 0, 'Table must be on valid col');
      var width = table.columns.length;
      var height = table.rows.length;
      var filterHeight = height + (table.headerRow ? 1 : 0);
      var tableHeight = filterHeight + (table.totalsRow ? 1 : 0); // autoFilterRef is a range that includes optional headers only

      table.autoFilterRef = colCache.encode(row, col, row + filterHeight - 1, col + width - 1); // tableRef is a range that includes optional headers and totals

      table.tableRef = colCache.encode(row, col, row + tableHeight - 1, col + width - 1);
      table.columns.forEach(function (column, i) {
        assert(column.name, "Column ".concat(i, " must have a name"));

        if (i === 0) {
          assign(column, 'totalsRowLabel', 'Total');
        } else {
          assign(column, 'totalsRowFunction', 'none');
          column.totalsRowFormula = _this.getFormula(column);
        }
      });
    }
  }, {
    key: "store",
    value: function store() {
      var _this2 = this;

      // where the table needs to store table data, headers, footers in
      // the sheet...
      var assignStyle = function assignStyle(cell, style) {
        if (style) {
          Object.keys(style).forEach(function (key) {
            cell[key] = style[key];
          });
        }
      };

      var worksheet = this.worksheet,
          table = this.table;
      var _table$tl2 = table.tl,
          row = _table$tl2.row,
          col = _table$tl2.col;
      var count = 0;

      if (table.headerRow) {
        var r = worksheet.getRow(row + count++);
        table.columns.forEach(function (column, j) {
          var style = column.style,
              name = column.name;
          var cell = r.getCell(col + j);
          cell.value = name;
          assignStyle(cell, style);
        });
      }

      table.rows.forEach(function (data) {
        var r = worksheet.getRow(row + count++);
        data.forEach(function (value, j) {
          var cell = r.getCell(col + j);
          cell.value = value;
          assignStyle(cell, table.columns[j].style);
        });
      });

      if (table.totalsRow) {
        var _r = worksheet.getRow(row + count++);

        table.columns.forEach(function (column, j) {
          var cell = _r.getCell(col + j);

          if (j === 0) {
            cell.value = column.totalsRowLabel;
          } else {
            var formula = _this2.getFormula(column);

            if (formula) {
              cell.value = {
                formula: column.totalsRowFormula,
                result: column.totalsRowResult
              };
            }
          }

          assignStyle(cell, column.style);
        });
      }
    }
  }, {
    key: "load",
    value: function load(worksheet) {
      var _this3 = this;

      // where the table will read necessary features from a loaded sheet
      var table = this.table;
      var _table$tl3 = table.tl,
          row = _table$tl3.row,
          col = _table$tl3.col;
      var count = 0;

      if (table.headerRow) {
        var r = worksheet.getRow(row + count++);
        table.columns.forEach(function (column, j) {
          var cell = r.getCell(col + j);
          cell.value = column.name;
        });
      }

      table.rows.forEach(function (data) {
        var r = worksheet.getRow(row + count++);
        data.forEach(function (value, j) {
          var cell = r.getCell(col + j);
          cell.value = value;
        });
      });

      if (table.totalsRow) {
        var _r2 = worksheet.getRow(row + count++);

        table.columns.forEach(function (column, j) {
          var cell = _r2.getCell(col + j);

          if (j === 0) {
            cell.value = column.totalsRowLabel;
          } else {
            var formula = _this3.getFormula(column);

            if (formula) {
              cell.value = {
                formula: column.totalsRowFormula,
                result: column.totalsRowResult
              };
            }
          }
        });
      }
    }
  }, {
    key: "cacheState",
    // ================================================================
    // TODO: Mutating methods
    value: function cacheState() {
      if (!this._cache) {
        this._cache = {
          ref: this.ref
        };
      }
    }
    /* eslint-disable no-unused-vars */

  }, {
    key: "addRow",
    value: function addRow(values, rowNumber) {
      // Add a row of data, either insert at rowNumber or append
      this.cacheState();
    }
  }, {
    key: "removeRow",
    value: function removeRow(rowNumber) {
      // Remove a row of data
      this.cacheState();
    }
  }, {
    key: "addColumn",
    value: function addColumn(column, values, colNumber) {
      // Add a new column, including column defn and values
      // Inserts at colNumber or adds to the right
      this.cacheState();
    }
  }, {
    key: "removeColumn",
    value: function removeColumn(colNumber) {
      // Remove a column with data
      this.cacheState();
    }
  }, {
    key: "assign",
    value: function assign(target, prop, value) {
      this.cacheState();
      target[prop] = value;
    }
    /* eslint-disable lines-between-class-members */

  }, {
    key: "model",
    get: function get() {
      return this.table;
    },
    set: function set(value) {
      this.table = value;
    }
  }, {
    key: "ref",
    get: function get() {
      return this.table.ref;
    },
    set: function set(value) {
      this.assign(this.table, 'ref', value);
    }
  }, {
    key: "name",
    get: function get() {
      return this.table.name;
    },
    set: function set(value) {
      this.table.name = value;
    }
  }, {
    key: "displayName",
    get: function get() {
      return this.table.displyName || this.table.name;
    }
  }, {
    key: "displayNamename",
    set: function set(value) {
      this.table.displayName = value;
    }
  }, {
    key: "headerRow",
    get: function get() {
      return this.table.headerRow;
    },
    set: function set(value) {
      this.assign(this.table, 'headerRow', value);
    }
  }, {
    key: "totalsRow",
    get: function get() {
      return this.table.totalsRow;
    },
    set: function set(value) {
      this.assign(this.table, 'totalsRow', value);
    }
  }, {
    key: "theme",
    get: function get() {
      return this.table.style.name;
    },
    set: function set(value) {
      this.table.style.name = value;
    }
  }, {
    key: "showFirstColumn",
    get: function get() {
      return this.table.style.showFirstColumn;
    },
    set: function set(value) {
      this.table.style.showFirstColumn = value;
    }
  }, {
    key: "showLastColumn",
    get: function get() {
      return this.table.style.showLastColumn;
    },
    set: function set(value) {
      this.table.style.showLastColumn = value;
    }
  }, {
    key: "showRowStripes",
    get: function get() {
      return this.table.style.showRowStripes;
    },
    set: function set(value) {
      this.table.style.showRowStripes = value;
    }
  }, {
    key: "showColumnStripes",
    get: function get() {
      return this.table.style.showColumnStripes;
    },
    set: function set(value) {
      this.table.style.showColumnStripes = value;
    }
  }]);

  return Table;
}();

module.exports = Table;
//# sourceMappingURL=table.js.map
